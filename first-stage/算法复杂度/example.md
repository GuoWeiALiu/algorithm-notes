### 个人总结：

1.时间复杂度是什么

> 一个函数，用大 O 表示，比如 O(1)、O(n)、O(logN)...
> 定性描述该算法的运行时间

**例如：**

- O(1)

```js
let i = 0;
i += 1;
// 每次执行这两行代码，都只会执行一次，所以时间复杂度为O(1)
```

- O(n)

```js
for (let i = 0; i < n; i++) {
  console.log(i);
}
// 因为for循环里面的代码会被执行n次，
// 随着n的值增大，里面也会增大，所以时间复杂度为O(n)
```

- O(1) + O(n) = O(n)

```js
let i = 0;
i += 1;
for (let j = 0; j < n; j++) {
  console.log(j);
}
// 如果两个复杂度先后排列，我们就把他们相加，
// 我们要取那个[增长趋势]更快的时间复杂度
```

- O(n) + O(n) = O(n^2)

```js
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    console.log(i, j);
  }
}
// 如果是嵌套循环的话就需要将两个时间复杂度相乘
// 相加和相乘不一样的
//  相乘就按照正常乘法计算
//  相加的话就忽略时间复杂度增长较小的那个，取较大的那个
```

- O(logN)

```js
let i = 1;
while (i < n) {
  console.log(i);
  i *= 2;
}
// 上面循环其实就是再求2的多少次方为n，所以它循环了logN次
// 所以时间复杂度为O(logN)
```

2.空间复杂度

> 一个函数，用大 O 表示，比如 O(1)、O(n)、O(logN)...
> 算法在运行过程中临时占用存储空间大小的量度

**例如：**

- O(1)

```js
let i = 0;
i += 1;
// 因为它只声明了单个变量，是恒定的一个内存单元，所以空间复杂度为O(1)
```

- O(n)

```js
const list = [];
for (let i = 0; i < n; i++) {
  list.push(i);
}
// 因为它声明了一个list数组，并在for循环里进行数组添加n个值，
// 用了n个值的内存单元，所以空间复杂度为O(n)
```

- O(n^2)

```js
const matrix = []
for (let i = 0; i< n; i++) {
  matrix.push([])
  for (let j = 0; j < n j++) {
    matrix[i].push(j)
  }
}
// 其实就是一个矩阵，因为矩阵就是一个二维数组，它存储了n^2个变量
// 所以空间复杂度就是O(n^2)
```
